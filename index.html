<!DOCTYPE html>
<html lang="pt-BR" class="dark"> <!-- PADR√ÉO √â DARK MODE -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Favicon (√çcone da Aba) -->
    <link rel="icon" type="logoPincel/png">
    <title>Acerte o desenho</title>
    <!-- Carrega Tailwind CSS para estiliza√ß√£o -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700;800&display=swap'); /* Fonte Poppins */
        
        /* Vari√°veis de Tema: Slate Minimalista */
        :root {
            --bg-color: #0c0c1e; 
            --card-bg: #1f2937; 
            --text-color: #f3f4f6; 
            --primary-color: #3b82f6; 
            --accent-color: #10b981; 
            --shadow-color: rgba(0, 0, 0, 0.5);
            --input-bg: #111827; 
        }
        
        /* Estilos Base para Adapta√ß√£o Total √† Tela (Mobile First) */
        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }
        body {
            font-family: 'Poppins', sans-serif; 
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.4s, color 0.4s;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh; 
            padding: 1.5rem 0;
            padding-bottom: 6rem; /* Espa√ßo para o rodap√© fixo */
        }
        .container {
            max-width: 1300px;
            width: 98%;
            background: var(--card-bg);
            box-shadow: 0 15px 40px var(--shadow-color); 
            border-radius: 1.5rem; 
            padding: 2rem; 
            margin: 0.5rem auto; 
            display: flex; 
            flex-direction: column;
        }
        /* CENTRALIZA√á√ÉO DE CONTE√öDO */
        .content-container {
            width: 100%;
            margin: 0 auto; 
            max-width: 95%;
            display: flex; 
            flex-direction: column;
            align-items: center; 
            justify-content: center;
        }
        /* Tela de Setup Centralizada e com largura m√°xima controlada */
        #setup-screen {
            max-width: 500px; 
        }
        

        /* CARD STYLE APLICADO EM MUITOS ELEMENTOS */
        .app-card {
            background-color: var(--input-bg);
            border-radius: 1rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            border: 1px solid #374151;
            padding: 1.5rem; 
        }
        .input-text-dark {
            background-color: var(--input-bg);
            border: 2px solid #374151;
            color: var(--text-color);
        }

        /* CANVAS CONTAINER: SEMPRE BRANCO */
        .canvas-container {
            border: 5px solid var(--primary-color); 
            background-color: #ffffff; 
            touch-action: none;
            cursor: crosshair;
            border-radius: 1.25rem;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.8); 
            flex-grow: 1; 
            max-width: 100%; 
        }

        /* GRADIENT BUTTON - INICIAR JOGO */
        .btn-gradient-primary {
            background-image: linear-gradient(45deg, #10b981, #3b82f6);
            box-shadow: 0 6px 15px rgba(59, 130, 246, 0.5);
            transition: all 0.3s ease;
        }
        .btn-gradient-primary:hover:not(:disabled) {
            background-image: linear-gradient(45deg, #3b82f6, #10b981);
            box-shadow: 0 8px 20px rgba(59, 130, 246, 0.7);
            transform: translateY(-2px);
        }
        .btn-gradient-primary:disabled {
            background: #4b5563; 
            box-shadow: none;
        }
        
        /* Estilos Padr√£o para Bot√µes de Sele√ß√£o (Pills) */
        .select-pill {
            background-color: #374151; 
            color: var(--text-color);
            border: 1px solid #475569;
            transition: all 0.2s;
        }
        .select-pill:hover {
            background-color: #4b5563;
        }
        .select-pill.active {
            background-color: var(--primary-color);
            color: white;
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.6);
            border-color: var(--primary-color);
            transform: scale(1.02); /* Suavizado */
        }
        
        /* Estilo para Overlays */
        #turn-reveal-overlay, #word-reveal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95); 
            z-index: 1000;
            display: none;
            place-items: center; 
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
    </style>
</head>
<body class="selection:bg-blue-600 selection:text-white">
<!-- Rodap√© com informa√ß√µes do desenvolvedor -->
<div id="developer-footer" class="fixed bottom-0 left-0 right-0 z-50 w-full text-center py-4 bg-gray-800 shadow-lg text-white">  
  <p class="text-sm flex justify-center items-center gap-4 flex-wrap px-2">  
    <span>Desenvolvido por Giovanni Fuentes Giannetti:</span>
    <!-- Instagram -->  
    <a href="https://instagram.com/giovanni.fg" target="_blank" class="text-pink-400 hover:text-pink-300 flex items-center gap-1">  
      <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" class="w-5 h-5">  
        <path d="M12 2.2c3.2 0 3.6 0 4.9.1 1.2.1 1.9.3 2.3.5.6.2 1 .6 1.4 1.1.4.4.9 1 1.1 1.6.2.4.4 1.1.5 2.3.1 1.3.1 1.7.1 4.9s0 3.6-.1 4.9c-.1 1.2-.3 1.9-.5 2.3-.2.6-.6 1-1.1 1.4-.4.4-1 .9-1.6 1.1-.4.2-1.1.4-2.3.5-1.3.1-1.7.1-4.9.1s-3.6 0-4.9-.1c-1.2-.1-1.9-.3-2.3-.5-.6-.2-1-.6-1.4-1.1-.4-.4-.9-1-1.1-1.6-.2-.4-.4-1.1-.5-2.3C2.2 15.6 2.2 15.2 2.2 12s0-3.6.1-4.9c.1-1.2.3-1.9.5-2.3.2-.6.6-1 1.1-1.4.4-.4 1-.9 1.6-1.1.4-.2 1.1.4 2.3.5C8.4 2.2 8.8 2.2 12 2.2m0-2.2C8.7 0 8.3 0 7 .1 5.7.2 4.7.4 4 .7c-.9.4-1.7 1-2.4 1.7C.9 3.1.3 3.9 0 4.8c-.3.7-.5 1.7-.6 3C-.7 9 .7 9.3.7 12s0 3 .1 4.2c.1 1.3.3 2.3.6 3 .3.9.9 1.7 1.6 2.4.7.7 1.5 1.3 2.4 1.6.7.3 1.7.5 3 .6 1.2.1 1.6.1 4.9.1s3.6 0 4.9-.1c1.3-.1 2.3-.3 3-.6.9-.3 1.7-.9 2.4-1.6.7-.7 1.3-1.5 1.6-2.4.3-.7.5-1.7.6-3 .1-1.2.1-1.6.1-4.9s0-3.6-.1-4.9c-.1-1.3-.3-2.3-.6-3-.3-.9-.9-1.7-1.6-2.4C21.1 1.6 20.3 1 19.4.7c-.7-.3-1.7-.5-3-.6C15.6 0 15.2 0 12 0z"/>  
        <path d="M12 5.8a6.2 6.2 0 1 0 0 12.4A6.2 6.2 0 0 0 12 5.8zm0 10.2a4 4 0 1 1 0-8.1 4 4 0 0 1 0 8.1zM18.4 4.6a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3z"/>  
      </svg>  
      @giovanni.fg  
    </a>  
    <!-- LinkedIn -->  
    <a href="https://linkedin.com/in/giovanni-fg" target="_blank" class="text-blue-400 hover:text-blue-300 flex items-center gap-1">  
      <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" class="w-5 h-5">  
        <path d="M4.98 3.5C4.98 5 3.9 6 2.5 6S0 5 0 3.5 1.12 1 2.5 1s2.48 1 2.48 2.5zM.5 8h4V24h-4V8zM8.5 8h3.8v2.2h.1c.5-.9 1.8-1.9 3.7-1.9 3.9 0 4.6 2.5 4.6 5.7V24h-4v-7.8c0-1.9 0-4.4-2.7-4.4-2.7 0-3.1 2.1-3.1 4.2V24h-4V8z"/>  
      </svg>  
      giovanni-fg  
    </a>  
  </p>  
</div>

    <!-- Overlay 1: Sua Vez (Aparece Primeiro) -->
    <div id="turn-reveal-overlay">
        <div class="text-center p-8 lg:p-12 rounded-xl bg-gray-900 shadow-2xl border-2 border-primary-color animate-pulse mx-4 max-w-lg">
            <p class="text-3xl lg:text-4xl font-extrabold mb-4 text-gray-300">PREPARE-SE!</p>
            <p class="text-5xl lg:text-6xl font-extrabold text-primary-color mb-6 tracking-wider" id="turn-drawer-name"></p>
            <p class="text-xl text-gray-400">√â a sua vez de desenhar!</p>
        </div>
    </div>

    <!-- Overlay 2: Revela√ß√£o da Palavra (Aparece em seguida) -->
    <div id="word-reveal-overlay">
        <div class="text-center p-8 lg:p-12 rounded-xl bg-gray-900 shadow-2xl border-2 border-red-500 mx-4 max-w-lg">
            <p class="text-3xl lg:text-4xl font-extrabold mb-4 text-gray-300 animate-pulse">PALAVRA SECRETA</p>
            <!-- PALAVRA SECRETA -->
            <p class="text-6xl lg:text-7xl font-extrabold text-red-400 mb-2 tracking-widest" id="secret-word-overlay"></p>
            <!-- TEMPO DE DESENHO (NOVO LOCAL) -->
            <p class="text-xl text-gray-400 font-medium">Tempo: <span id="drawing-time-display" class="font-extrabold text-red-400">0s</span></p>

            <p class="text-lg text-gray-500 mt-4">Memorize. O desenho come√ßa em <span id="reveal-timer" class="font-extrabold text-white">3</span>s.</p>
        </div>
    </div>

    <div id="app" class="container">
        
        <!-- Header com T√≠tulo (Centralizado) -->
        <header class="flex justify-center items-center mb-8 border-b pb-4 border-gray-700 w-full">
            <h1 class="text-3xl lg:text-4xl font-extrabold text-primary-color tracking-wider text-center">ACERTE O DESENHO</h1>
        </header>

        <!-- 1. Tela de Configura√ß√£o (Alinhada e Minimalista) -->
        <div id="setup-screen" class="space-y-8 content-container mx-auto">
            <h2 class="text-3xl font-bold text-gray-100 border-b border-gray-700 pb-2 text-center w-full">Configura√ß√£o do Jogo</h2>
            
            <!-- Entrada de Jogadores -->
            <div id="players-input-container" class="space-y-4 app-card border-l-4 border-blue-600 w-full">
                <label class="block text-xl font-bold text-gray-300 text-center">Jogadores Atuais (2‚Äì10)</label>
                <div class="flex flex-wrap gap-3 mb-3 justify-center" id="player-list">
                    <!-- Nomes dos jogadores ser√£o adicionados aqui -->
                </div>
                <div id="player-input-group" class="relative">
                    <!-- Input com Bot√£o Integrado -->
                    <input type="text" id="new-player-name" 
                           placeholder="Nome do Jogador..." 
                           onkeyup="if(event.key === 'Enter') addPlayer()"
                           class="input-text-dark w-full p-3 pr-12 rounded-xl placeholder-gray-500 focus:ring-2 focus:ring-primary-color shadow-inner text-lg">
                    <button id="add-player-btn" onclick="addPlayer()" class="bg-blue-600 text-white w-8 h-8 rounded-full font-bold text-xl hover:bg-blue-700 transition duration-200 shadow-lg flex items-center justify-center absolute right-2 top-1/2 transform -translate-y-1/2">
                        +
                    </button>
                </div>
            </div>

            <!-- Op√ß√µes de Rodadas, Tempo e Temas (Alinhado) -->
            <div class="space-y-5 w-full">
                
                <!-- Modo de Rodadas (Bot√µes) -->
                <div class="app-card">
                    <label class="block text-lg font-medium text-gray-300 mb-3 text-center">Modo de Rodadas</label>
                    <div class="flex space-x-2 justify-center" id="round-mode-selector">
                        <button onclick="setRoundMode('alternated', this)" data-mode="alternated" class="select-pill active px-4 py-2 rounded-full text-base font-semibold transition">Alternadas</button>
                        <button onclick="setRoundMode('per_player', this)" data-mode="per_player" class="select-pill px-4 py-2 rounded-full text-base font-semibold transition">Por Jogador</button>
                    </div>
                </div>

                <!-- N√∫mero de Rodadas (Slider) -->
                <div class="app-card">
                    <label for="num-rounds-slider" class="block text-lg font-medium text-gray-300 mb-4 text-center">
                        N¬∫ de Vezes: <span id="rounds-value" class="font-extrabold text-2xl text-primary-color">1</span>
                    </label>
                    <input type="range" id="num-rounds-slider" value="1" min="1" max="20" oninput="document.getElementById('rounds-value').textContent = this.value" class="w-full">
                </div>
                
                <!-- Tempo por Rodada (Bot√µes) -->
                <div class="app-card">
                    <label class="block text-lg font-medium text-gray-300 mb-3 text-center">Tempo de Desenho</label>
                    <div class="flex space-x-3 flex-wrap justify-center" id="time-selector">
                        <button onclick="setTimeOption('10', this)" data-time="10" class="select-pill px-4 py-2 rounded-full text-base transition">10s</button>
                        <button onclick="setTimeOption('30', this)" data-time="30" class="select-pill active px-4 py-2 rounded-full text-base transition">30s</button>
                        <button onclick="setTimeOption('60', this)" data-time="60" class="select-pill px-4 py-2 rounded-full text-base transition">60s</button>
                        <button onclick="setTimeOption('random', this)" data-time="random" class="select-pill px-4 py-2 rounded-full text-base transition">Sorteado</button>
                    </div>
                </div>
                
                <!-- Temas de Palavras (Bot√µes) -->
                <div class="app-card">
                    <label class="block text-lg font-medium text-gray-300 mb-3 text-center">Temas de Palavras (Selecione)</label>
                    <div id="theme-selection" class="flex flex-wrap gap-3 justify-center">
                        <!-- Bot√µes de tema injetados aqui -->
                    </div>
                </div>
            </div>

            <button onclick="startGame()" id="start-game-btn" class="w-full text-white text-3xl p-5 rounded-xl font-extrabold btn-gradient-primary disabled:bg-gray-700 disabled:cursor-not-allowed shadow-xl tracking-wider">
                INICIAR JOGO
            </button>
            <p id="setup-error" class="text-red-400 text-center font-medium hidden">M√≠nimo 2 jogadores e 1 tema selecionado s√£o necess√°rios.</p>
        </div>

        <!-- 2. Tela de Desenho -->
        <div id="drawing-screen" class="hidden space-y-6 content-container">
            
            <!-- BARRA DE STATUS (TOPO) -->
            <div class="flex flex-wrap justify-between items-center p-4 app-card border-l-4 border-primary-color text-base lg:text-xl w-full">
                <div class="font-bold text-gray-300">Rodada <span id="current-round-display">1</span> / <span id="total-rounds-display">1</span></div>
                <div class="font-extrabold text-red-400 text-xl lg:text-3xl animate-pulse">
                    TEMPO: <span id="timer-display">0</span>s
                </div>
                <div class="font-bold text-gray-300">
                    Desenhista: <span id="drawer-name" class="text-primary-color"></span>
                </div>
            </div>

            <!-- GRID PRINCIPAL: CANVAS (2/3) + PLACAR (1/3) -->
            <div class="grid lg:grid-cols-3 gap-6 w-full">
                
                <!-- COLUNA 1: CANVAS E FERRAMENTAS -->
                <div class="lg:col-span-2 space-y-4 order-2 lg:order-1"> 
                    <div id="canvas-container" class="canvas-container w-full aspect-[4/3] max-w-full mx-auto">
                        <canvas id="drawing-canvas"></canvas>
                    </div>
                    
                    <!-- CONTROLES DE DESENHO (Centralizado e Compacto) -->
                    <div id="drawing-controls" class="flex flex-wrap gap-4 justify-center p-4 app-card transition duration-300 w-full mx-auto">
                        
                        <!-- Cor e Tamanho (Agrupados) -->
                        <div class="flex items-center gap-3">
                            <label for="color-picker" class="flex items-center text-gray-300 font-medium text-sm lg:text-base">Cor:</label>
                            <input type="color" id="color-picker" value="#000000" title="Cor" class="w-10 h-10 lg:w-12 lg:h-12 rounded-full border-2 border-gray-500 cursor-pointer p-0 shadow-md">
                        </div>

                        <!-- SUBSTITU√çDO: Slider de Tamanho (Drag Slider) -->
                        <div id="size-controls-slider" class="flex flex-col items-center justify-center w-32">
                            <label for="brush-size-slider" class="text-gray-300 font-medium text-sm lg:text-base mb-1 whitespace-nowrap">
                                Tamanho: <span id="brush-size-value" class="font-bold">5</span>
                            </label>
                            <input type="range" id="brush-size-slider" min="2" max="50" value="5" oninput="setSize(this.value)" class="w-full">
                        </div>
                        <!-- FIM DO SLIDER -->

                        <span class="border-l border-gray-700 mx-3 hidden sm:inline-block"></span>
                        
                        <!-- Ferramentas (√çcones Limpos) -->
                        <button onclick="setMode('pen')" id="pen-btn" class="tool-btn active p-3 bg-blue-700 text-white rounded-xl font-semibold transition duration-200 flex items-center shadow-lg text-base" title="Pincel">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.536l12.232-12.232z"></path></svg>
                        </button>

                        <button onclick="setMode('eraser')" id="eraser-btn" class="tool-btn p-3 bg-yellow-500 text-white rounded-xl font-semibold hover:bg-yellow-600 transition duration-200 flex items-center shadow-lg text-base" title="Borracha">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                        </button>
                        
                        <button onclick="setMode('fill')" id="fill-btn" class="tool-btn p-3 bg-red-600 text-white rounded-xl font-semibold hover:bg-red-700 transition duration-200 flex items-center shadow-lg text-base" title="Preencher">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414l2.828 2.828m-2.828-2.828L11 5m1.414 1.414L15 9.828m-4.242-4.242L11 5m1.414 1.414l-4.242 4.242m0 0l-1.414 1.414M18 10v4a2 2 0 01-2 2H8a2 2 0 01-2-2v-4"></path></svg>
                        </button>
                        
                        <button onclick="clearCanvas()" class="p-3 bg-gray-500 text-white rounded-xl font-semibold hover:bg-gray-600 transition duration-200 flex items-center shadow-lg text-base" title="Limpar Tudo">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                        </button>
                    </div>
                </div>

                <!-- COLUNA 2: PLACAR (Sempre vis√≠vel) -->
                <div class="lg:col-span-1 space-y-4 order-1 lg:order-2">
                    <div class="p-5 app-card border-l-4 border-yellow-500 w-full">
                        <h3 class="text-xl font-bold text-gray-100 mb-4 tracking-wide">PLACAR ATUAL</h3>
                        <div id="score-board" class="space-y-3">
                            <!-- Placar √© atualizado aqui -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 3. Tela de Adivinha√ß√£o (Apenas Desenho e Palpites - Minimalista) -->
        <div id="guessing-screen" class="hidden space-y-6 content-container max-w-4xl">
            <h3 class="text-3xl font-bold text-gray-100 mb-5 tracking-wide border-b border-gray-700 pb-3 w-full text-center">ADIVINHE A PALAVRA!</h3>

            <!-- √Årea do Desenho Final (Garantindo que n√£o seja cortado) -->
            <div class="canvas-container w-full aspect-[4/3] max-w-full mx-auto flex items-center justify-center">
                <canvas id="final-drawing-canvas"></canvas>
            </div>
            
            <!-- Campos de Palpite (Centralizados) -->
            <div id="guesser-inputs-container" class="space-y-4 app-card w-full">
                <p id="guessing-prompt" class="text-base text-gray-400 font-medium mb-4 text-center">Voc√™ tem 3 chutes por pessoa.</p>
                <div id="guesser-inputs" class="grid sm:grid-cols-2 lg:grid-cols-3 gap-4">
                    <!-- Campos de palpite s√£o injetados aqui -->
                </div>
            </div>
        </div>


        <!-- 4. Tela de Fim de Rodada (Visual Aprimorado e Palavra Destacada) -->
        <div id="round-end-screen" class="hidden text-center p-10 app-card border-4 border-green-500 content-container max-w-xl mx-auto">
            <h2 class="text-3xl lg:text-4xl font-extrabold text-green-400 mb-8 tracking-widest">FIM DA RODADA! üéâ</h2>
            <div class="mb-8 p-6 bg-gray-900 rounded-xl shadow-inner border border-green-700">
                <p class="text-xl text-gray-300 mb-4 font-semibold">A palavra secreta era:</p>
                <!-- PALAVRA BEM GRANDE -->
                <p id="final-word" class="text-red-400 font-extrabold text-6xl lg:text-7xl tracking-widest"></p>
            </div>

            <div id="round-winners" class="space-y-4 text-left inline-block bg-gray-900 p-8 rounded-xl shadow-xl w-full border border-gray-700">
                <p class="font-extrabold text-xl lg:text-2xl text-gray-100 border-b pb-3 mb-4 border-gray-700">Pontua√ß√£o da Rodada:</p>
                
                <div id="drawer-score-visual" class="flex justify-between items-center text-lg lg:text-xl p-3 bg-blue-900/50 rounded-lg border border-blue-600 mb-4">
                    <span class="font-bold text-blue-300">Desenhista: <span id="drawer-name-end"></span></span>
                    <span id="drawer-score-earned" class="font-extrabold text-white"></span>
                </div>

                <ul id="correct-guesses-list" class="space-y-3 text-gray-300 text-lg">
                    <!-- Acertos s√£o listados aqui com visual de pontua√ß√£o -->
                </ul>
            </div>
            
            <div class="flex justify-center mt-10 w-full">
                <button onclick="nextRound()" class="bg-blue-600 text-white text-2xl p-4 rounded-xl font-bold hover:bg-blue-700 transition duration-300 shadow-xl min-w-[250px] tracking-wider">
                    PR√ìXIMA RODADA
                </button>
            </div>
        </div>

        <!-- 5. Tela de Fim de Jogo -->
        <div id="game-end-screen" class="hidden text-center p-10 app-card border-4 border-purple-500 content-container max-w-xl mx-auto">
            <h2 class="text-3xl lg:text-4xl font-extrabold text-purple-400 mb-8 tracking-widest">FIM DE JOGO! üèÜ</h2>
            <h3 class="text-2xl font-semibold text-gray-100 mb-6">Ranking Final</h3>
            <div id="final-ranking" class="space-y-4 mx-auto w-full">
                <!-- Ranking √© exibido aqui -->
            </div>
            
            <button onclick="location.reload()" class="mt-8 w-full bg-accent-color text-white text-xl p-4 rounded-xl font-bold hover:bg-green-700 transition duration-200 shadow-xl tracking-wider">
                JOGAR DE NOVO
            </button>
        </div>
        
    </div>

    <script>
        // Vari√°veis Globais de Estado do Jogo
        let gameState = {
            players: [], 
            numRoundsPerPlayer: 1,
            totalRounds: 0,
            currentRound: 0,
            timeOption: '30',
            roundMode: 'alternated', 
            drawerIndex: 0,
            wordToDraw: '',
            timer: null,
            timeLeft: 0, 
            drawerId: null,
            playersWhoGuessed: new Set(),
            hasDrawerScored: false,
            isDrawingPhase: true, 
            selectedThemes: [],
            drawerHistory: {}, 
        };

        // Constantes de Pontua√ß√£o
        const SCORE_DRAWER = 100;
        const SCORE_GUESSER_BASE = 60;
        const SCORE_BONUS_PER_SEC = 2; 
        const SCORE_PENALTY = 10; 
        const SCORE_PERFECT_GUESS = 50; 
        const REVEAL_TIME = 3; 
        
        // Vari√°veis do Canvas
        let canvas, ctx;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let color = '#000000';
        let size = 5; 
        let mode = 'pen'; 
        let canvasDrawingData = null; 
        
        // --- Dicion√°rio de Palavras (Mantido por ser extenso e completo) ---
        const WORD_CATEGORIES = {
            "Objetos": ["Cadeira", "Mesa", "L√°pis", "Rel√≥gio", "Livro", "Tesoura", "√ìculos", "Martelo", "Chave", "Travesseiro", "Espelho", "Vaso", "Garrafa", "Toalha", "Vela", "Escada", "Corda", "Carrinho", "Boneca", "Bola", "Telefone", "Faca", "Copo", "Prato", "Microfone", "Ventilador", "Calend√°rio", "Caderno", "Pena", "Lupa", "Lanterna", "Bal√£o", "Cofre", "Gaveta", "Caixa", "Porta", "Janela", "Pincel", "Teclado", "Mouse", "Impressora", "Monitor", "Fio", "Tomada", "R√©gua", "Apagador", "Giz", "Quadro", "Mapa", "Globo", "Chaveiro", "Capacete", "Bolsa", "Carteira", "Guarda-chuva", "Bot√£o", "Z√≠per", "Agulha", "Linha", "Alfinete", "Cinto", "Meia", "Luva", "Cachecol", "Chap√©u", "Bon√©", "Vassoura", "P√°", "Rodo", "Esponja", "Sabonete", "Shampoo", "Escova", "Pente", "Secador", "Alicate", "Trena", "Parafuso", "Prego", "Porca", "Pneu", "Bateria", "Lanterna", "B√∫ssola", "Bin√≥culos", "Telesc√≥pio", "Microsc√≥pio", "Term√¥metro", "Sino", "Tambor", "Flauta", "Viol√£o", "Piano", "Fones", "Caixa de Som", "C√¢mera", "Filme", "Trip√©", "Controle", "Pilhas"],
            "Ve√≠culos": ["Carro", "Bicicleta", "Avi√£o", "Barco", "Trem", "√înibus", "Moto", "Caminh√£o", "Trator", "Submarino", "Helic√≥ptero", "Jato", "Veleiro", "Lancha", "Canoa", "Jet Ski", "Patins", "Skate", "Patinete", "Monociclo", "Bal√£o", "Dirig√≠vel", "Foguete", "Nave Espacial", "Satelite", "Drone", "M√°quina de Costura", "Retroescavadeira", "Guindaste", "Empilhadeira", "Ambul√¢ncia", "Viaturas", "Taxi", "Van", "Reboque", "Carreta", "Tanque", "Jipe", "Carro de M√£o", "Carrinho de Golfe", "Telef√©rico", "Gondola", "Bondinho", "Metr√¥", "Triciclo", "Quadriciclo", "Rollers", "Hoverboard", "Trotinete", "Cadeirinha", "Boia", "Prancha", "Caiaque", "Bote", "Transatl√¢ntico", "Fragata", "Cruzador", "Navio Negreiro", "Gale√£o", "Barca", "Tuk Tuk", "Riquix√°", "Carruagem", "Charrete", "Sled", "Mula", "Camelo", "Jangada", "Draga", "Balsa", "Monotrilho", "Locomotiva", "Vag√£o", "Trem Bala", "Ferry", "Snowmobile", "Buggy", "Off-road", "Convers√≠vel", "Pickup", "Sedan", "Hatch", "SUV", "Crossover", "Minivan", "Roadster", "Coupe", "Limousine", "Motorhome", "Trailer"],
            "Animais": ["Cachorro", "Gato", "Elefante", "Le√£o", "Tigre", "Girafa", "Macaco", "Panda", "Coelho", "Esquilo", "Peixe", "Tubar√£o", "Baleia", "Golfinho", "Polvo", "Estrela do Mar", "Caranguejo", "Camar√£o", "Tartaruga", "Cobra", "Lagarto", "Jacar√©", "Crocodilo", "Sapo", "R√£", "P√°ssaro", "√Åguia", "Coruja", "Pombo", "Galinha", "Pato", "Ganso", "Peru", "Boi", "Vaca", "Cavalo", "Ovelha", "Cabra", "Porco", "Rato", "Morcego", "Urso", "Lobo", "Raposa", "Cervo", "Veado", "Zebra", "Rinoceronte", "Hipop√≥tamo", "Lhama", "Alpaca", "Canguru", "Coala", "Pinguim", "Foca", "Morsa", "Chimpanz√©", "Gorila", "Orangotango", "Gib√£o", "Formiga", "Abelha", "Borboleta", "Aranha", "Mosquito", "Joaninha", "Louva-a-Deus", "Gafanhoto", "Vespa", "Lib√©lula", "Escorpi√£o", "Centopeia", "Minhoca", "Lesma", "Caracol", "Grilo", "Besouro", "Barata", "Tra√ßa", "Pulga", "Corvo", "Gralha", "Papagaio", "Arara", "Can√°rio", "Calopsita", "Curi√≥", "Beija-flor", "Pelicano", "Flamingo", "Tatu", "Capivara", "Quati", "Jaguatirica", "Mico", "Tamandu√°", "Bicho-pregui√ßa", "Piranha", "Surubim", "Dourado"],
            "Comida": ["Pizza", "Hamb√∫rguer", "Batata Frita", "Sorvete", "Chocolate", "Bolo", "P√£o", "Queijo", "Ovo", "Leite", "Caf√©", "Ch√°", "Suco", "√Ågua", "Refrigerante", "Frango", "Carne", "Peixe", "Salada", "Tomate", "Cenoura", "Batata", "Arroz", "Feij√£o", "Macarr√£o", "Sopa", "Melancia", "Banana", "Ma√ß√£", "Laranja", "Uva", "Manga", "Morango", "Abacaxi", "Lim√£o", "Azeite", "Vinagre", "Sal", "A√ß√∫car", "Pimenta", "Alho", "Cebola", "Brocolis", "Couve", "Milho", "Ervilha", "Torta", "Cookie", "Donut", "Panqueca", "Waffle", "Gelatina", "Pudim", "Mousse", "Iogurte", "Cereal", "Mingau", "Geleia", "Manteiga", "Torrada", "Bacon", "Salsicha", "Presunto", "Pastel", "Coxinha", "Kibe", "Empada", "Sandu√≠che", "Wrap", "Taco", "Burrito", "Sushi", "Sashimi", "Temaki", "Noodle", "Ramen", "Pipoca", "Amendoim", "Castanha", "Nozes", "Pistache", "Caju", "Gengibre", "Canela", "Manjeric√£o", "Or√©gano", "Alecrim", "P√°prica", "Curry", "A√ßafr√£o", "Tapioca", "Cuscuz", "Pamonha", "Churros", "Brigadeiro", "Beijinho", "Quindim", "Doce de Leite", "Goiabada", "P√©-de-Moleque"],
            "Lugares": ["Casa", "Escola", "Parque", "Praia", "Montanha", "Floresta", "Deserto", "Rio", "Lago", "Oceano", "Hospital", "Banco", "Correio", "Delegacia", "Igreja", "Templo", "Shopping", "Cinema", "Teatro", "Museu", "Biblioteca", "Livraria", "Padaria", "Restaurante", "Supermercado", "Academia", "Piscina", "Est√°dio", "Quadra", "Aeroporto", "Porto", "Esta√ß√£o", "Rodovi√°ria", "Ponte", "T√∫nel", "Pris√£o", "F√°brica", "Escrit√≥rio", "Laborat√≥rio", "Rua", "Avenida", "Pra√ßa", "Jardim", "Terra√ßo", "Varanda", "S√≥t√£o", "Por√£o", "Garagem", "Cozinha", "Banheiro", "Quarto", "Sala", "Corredor", "Elevador", "Escada Rolante", "Cabana", "Tenda", "Castelo", "Pal√°cio", "Pir√¢mide", "Torre", "Farol", "Vulc√£o", "Caverna", "Ilha", "Pen√≠nsula", "C√¢nion", "Geleira", "P√¢ntano", "Vila", "Cidade", "Capital", "Prov√≠ncia", "Continente", "Pa√≠s", "Planeta", "Lua", "Sol", "Gal√°xia", "Universo", "Posto de Gasolina", "Hotel", "Motel", "Pousada", "Resort", "Acampamento", "Ref√∫gio", "Posto de Sa√∫de", "Cl√≠nica", "Farm√°cia", "Galerias", "Feira", "Mercado", "Confeitaria", "A√ßougue", "Sapataria", "Loja de Roupas", "Pet Shop", "Floricultura", "Oficina"]
        };
        let availableWords = []; 

        // Flood Fill e Canvas logic
        function hexToRgba(hex) {
            const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16), 255] : [0, 0, 0, 255];
        }

        function floodFill(startX, startY) { 
            const fillRgba = hexToRgba(color);
            if (!ctx) return;
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
            const getIndex = (x, y) => (y * canvasWidth + x) * 4;
            const pixelIndex = getIndex(startX, startY);

            if (startX < 0 || startX >= canvasWidth || startY < 0 || startY >= canvasHeight) return;

            const targetR = imageData.data[pixelIndex];
            const targetG = imageData.data[pixelIndex + 1];
            const targetB = imageData.data[pixelIndex + 2];
            const targetA = imageData.data[pixelIndex + 3];

            if (targetR === fillRgba[0] && targetG === fillRgba[1] && targetB === fillRgba[2] && targetA === fillRgba[3]) return;

            const stack = [[startX, startY]];
            const matchColor = (index) => 
                imageData.data[index] === targetR && imageData.data[index + 1] === targetG && imageData.data[index + 2] === targetB && imageData.data[index + 3] === targetA;

            const setColor = (index) => {
                imageData.data[index] = fillRgba[0];
                imageData.data[index + 1] = fillRgba[1];
                imageData.data[index + 2] = fillRgba[2];
                imageData.data[index + 3] = fillRgba[3];
            };

            while (stack.length) {
                let [x, y] = stack.pop();
                let index = getIndex(x, y);

                if (x >= 0 && x < canvasWidth && y >= 0 && y < canvasHeight && matchColor(index)) {
                    setColor(index);
                    stack.push([x + 1, y]);
                    stack.push([x - 1, y]);
                    stack.push([x, y + 1]);
                    stack.push([x, y - 1]);
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        // --- Fun√ß√µes de Utilit√°rio ---

        function selectNewWord() {
            if (availableWords.length === 0) {
                gameState.selectedThemes.forEach(theme => { 
                    availableWords.push(...WORD_CATEGORIES[theme]); 
                });
                availableWords.sort(() => Math.random() - 0.5);
            }
            const randomIndex = Math.floor(Math.random() * availableWords.length);
            const word = availableWords[randomIndex];
            availableWords.splice(randomIndex, 1); 
            return word;
        }

        function normalizeText(text) {
            return text.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-z0-9]/g, ''); 
        }

        function checkGuess(guess, secretWord) {
            const normalizedGuess = normalizeText(guess);
            const normalizedSecret = normalizeText(secretWord);
            
            if (normalizedGuess === normalizedSecret) return true;
            if (normalizedSecret.includes(normalizedGuess) && normalizedGuess.length >= 3) return true;
            if (normalizedGuess.includes(normalizedSecret) && normalizedSecret.length >= 3) return true;

            return false;
        }

        function getRoundTime() {
            const option = gameState.timeOption;
            if (option === 'random') {
                const times = [10, 30, 60];
                return times[Math.floor(Math.random() * times.length)];
            }
            return parseInt(option, 10);
        }
        
        // --- Setup e L√≥gica de Jogo ---

        function setRoundMode(mode, button) {
            gameState.roundMode = mode;
            document.querySelectorAll('#round-mode-selector .select-pill').forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
        }

        function setTimeOption(time, button) {
            gameState.timeOption = time;
            document.querySelectorAll('#time-selector .select-pill').forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
        }
        
        function calculateTotalRounds() {
            const numPlayers = gameState.players.length;
            const numTimes = parseInt(document.getElementById('num-rounds-slider').value, 10);
            
            if (gameState.roundMode === 'per_player') {
                gameState.totalRounds = numPlayers * numTimes;
                gameState.numRoundsPerPlayer = numTimes;
            } else { 
                gameState.totalRounds = numTimes;
                gameState.numRoundsPerPlayer = Math.ceil(numTimes / numPlayers);
            }
        }

        function getNextDrawerId() {
            const numPlayers = gameState.players.length;
            if (gameState.roundMode === 'alternated') {
                gameState.drawerIndex = (gameState.currentRound - 1) % numPlayers;
                return gameState.players[gameState.drawerIndex].id;
            } else { 
                gameState.players.forEach(p => { if (!gameState.drawerHistory[p.id]) gameState.drawerHistory[p.id] = 0; });
                const eligibleDrawers = gameState.players.filter(p => gameState.drawerHistory[p.id] < gameState.numRoundsPerPlayer);
                if (eligibleDrawers.length === 0) return null; 
                eligibleDrawers.sort((a, b) => {
                    const countA = gameState.drawerHistory[a.id];
                    const countB = gameState.drawerHistory[b.id];
                    if (countA !== countB) return countA - countB;
                    return a.id.localeCompare(b.id);
                });
                const nextDrawer = eligibleDrawers[0];
                gameState.drawerHistory[nextDrawer.id]++;
                return nextDrawer.id;
            }
        }

        function startGame() {
            // Valida√ß√£o para iniciar o jogo
            if (gameState.players.length < 2 || gameState.selectedThemes.length === 0) {
                 document.getElementById('setup-error').textContent = "M√≠nimo 2 jogadores e 1 tema selecionado s√£o necess√°rios.";
                 document.getElementById('setup-error').classList.remove('hidden');
                 return;
            }
            document.getElementById('setup-error').classList.add('hidden');
            
            // Esconde o rodap√© ao iniciar
            document.getElementById('developer-footer').style.display = 'none';

            availableWords = [];
            gameState.selectedThemes.forEach(theme => { availableWords.push(...WORD_CATEGORIES[theme]); });
            availableWords.sort(() => Math.random() - 0.5);

            calculateTotalRounds();
            gameState.players.forEach(p => { p.score = 0; p.guessesLeft = 3; p.errors = 0; }); 
            gameState.players.sort(() => Math.random() - 0.5); 
            gameState.drawerHistory = {};

            document.getElementById('setup-screen').classList.add('hidden');
            document.getElementById('drawing-screen').classList.remove('hidden');

            canvas = document.getElementById('drawing-canvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            setupCanvasListeners();

            document.getElementById('total-rounds-display').textContent = gameState.totalRounds;
            
            setTimeout(startNextRound, 50); 
        }

        function startNextRound() {
            if (gameState.currentRound >= gameState.totalRounds) return endGame();

            document.getElementById('round-end-screen').classList.add('hidden');
            document.getElementById('guessing-screen').classList.add('hidden');
            document.getElementById('drawing-screen').classList.remove('hidden');

            gameState.isDrawingPhase = true;
            gameState.currentRound++;
            document.getElementById('current-round-display').textContent = gameState.currentRound;

            gameState.drawerId = getNextDrawerId();

            if (!gameState.drawerId) return endGame(); 
            
            const drawer = gameState.players.find(p => p.id === gameState.drawerId);
            gameState.wordToDraw = selectNewWord(); 
            gameState.playersWhoGuessed = new Set();
            gameState.hasDrawerScored = false;
            
            document.getElementById('drawer-name').textContent = drawer.name;
            gameState.players.forEach(p => { p.guessesLeft = 3; p.errors = 0; }); 
            
            clearCanvas();
            renderScoreBoard();
            
            // Fluxo de revela√ß√£o: 1. Sua Vez -> 2. Palavra Secreta -> 3. Desenho
            showTurnReveal(drawer.name);
        }

        function showTurnReveal(drawerName) {
             document.getElementById('turn-drawer-name').textContent = drawerName;
             document.getElementById('turn-reveal-overlay').style.display = 'grid';

             setTimeout(() => {
                 document.getElementById('turn-reveal-overlay').style.display = 'none';
                 drawPhaseReveal();
             }, 1500);
        }
        
        function drawPhaseReveal() {
            document.getElementById('secret-word-overlay').textContent = gameState.wordToDraw;
            
            // Exibe o tempo de desenho total abaixo da palavra
            document.getElementById('drawing-time-display').textContent = getRoundTime() + 's'; 
            
            document.getElementById('word-reveal-overlay').style.display = 'grid'; 
            
            let revealTime = REVEAL_TIME;
            const revealTimerEl = document.getElementById('reveal-timer');
            revealTimerEl.textContent = revealTime;
            
            const roundStartTime = Date.now();
            
            const revealTimerInterval = setInterval(() => {
                revealTime--;
                revealTimerEl.textContent = revealTime;
                
                if (revealTime <= 0) {
                    clearInterval(revealTimerInterval);
                    document.getElementById('word-reveal-overlay').style.display = 'none'; 
                    startDrawingPhase(roundStartTime);
                }
            }, 1000);
        }

        function startDrawingPhase(roundStartTime) {
            gameState.isDrawingPhase = true;
            gameState.timeStart = roundStartTime;
            document.getElementById('drawing-controls').classList.remove('opacity-50', 'pointer-events-none');

            gameState.timeLeft = getRoundTime();
            document.getElementById('timer-display').textContent = gameState.timeLeft;

            gameState.timer = setInterval(updateTimer, 1000);
        }

        function updateTimer() {
            gameState.timeLeft--;
            document.getElementById('timer-display').textContent = gameState.timeLeft;

            if (gameState.timeLeft <= 0) {
                endDrawingPhase();
            }
        }
        
        function endDrawingPhase() {
            if (gameState.timer) {
                clearInterval(gameState.timer);
            }
            if (!gameState.isDrawingPhase) return;
            
            gameState.isDrawingPhase = false;
            
            const timeElapsed = Date.now() - gameState.timeStart;
            const roundDuration = getRoundTime() * 1000;
            gameState.timeLeft = Math.max(0, Math.ceil((roundDuration - timeElapsed) / 1000));
            
            // 1. Captura o desenho final
            canvasDrawingData = canvas.toDataURL();

            // 2. Muda para a tela de adivinha√ß√£o
            document.getElementById('drawing-screen').classList.add('hidden');
            document.getElementById('guessing-screen').classList.remove('hidden');

            // 3. Renderiza o desenho na nova tela
            const finalCanvas = document.getElementById('final-drawing-canvas');
            const finalCtx = finalCanvas.getContext('2d');
            
            const tempImg = new Image();
            tempImg.onload = function() {
                // CORRE√á√ÉO: Resizing robusto para a tela final (Anti-corte)
                const rect = finalCanvas.parentNode.getBoundingClientRect();
                const aspectRatio = tempImg.width / tempImg.height;
                finalCanvas.width = rect.width;
                finalCanvas.height = rect.width / aspectRatio;
                finalCtx.drawImage(tempImg, 0, 0, finalCanvas.width, finalCanvas.height);
                finalCanvas.dataset.hasImage = 'true';
            };
            tempImg.src = canvasDrawingData;
            
            // 4. Habilita palpites
            renderGuesserInputs(); 
        }

        function handleGuess(event, playerId, isButton) {
            let input;
            
            if (isButton) {
                // Chamado pelo bot√£o
                input = document.getElementById(`guess-${playerId}`);
            } else if (event.key !== 'Enter') {
                return;
            } else {
                // Chamado pela tecla Enter
                input = event.target;
            }
            
            const guess = input.value.trim();
            if (!guess) return; 

            const player = gameState.players.find(p => p.id === playerId);
            if (!player || player.guessesLeft <= 0 || gameState.playersWhoGuessed.has(playerId)) return;
            
            input.value = ''; // Limpa o input imediatamente

            if (checkGuess(guess, gameState.wordToDraw)) {
                
                const timeBonus = gameState.timeLeft * SCORE_BONUS_PER_SEC;
                let totalScore = SCORE_GUESSER_BASE + timeBonus;
                let perfectBonus = 0;

                if (player.errors === 0) {
                    perfectBonus = SCORE_PERFECT_GUESS;
                    totalScore += perfectBonus;
                }

                player.score += totalScore;
                gameState.playersWhoGuessed.add(playerId);
                
                if (!gameState.hasDrawerScored) {
                    const drawer = gameState.players.find(p => p.id === gameState.drawerId);
                    if (drawer) {
                        drawer.score += SCORE_DRAWER;
                        gameState.hasDrawerScored = true;
                    }
                }

                // Feedback de acerto
                input.value = `ACERTOU! (+${totalScore})`;
                input.disabled = true;
                input.classList.add('bg-green-500/50', 'disabled-guess');
                document.getElementById(`guesses-left-${playerId}`).textContent = `(ACERTOU!)`;
                document.getElementById(`guess-btn-${playerId}`).disabled = true;
                
                renderScoreBoard();
                
                const numGuessers = gameState.players.length - 1;
                if (gameState.playersWhoGuessed.size >= numGuessers) endRound();

            } else {
                // L√ìGICA DE ERRO CORRIGIDA E MELHORADA
                player.score -= SCORE_PENALTY; 
                player.guessesLeft--;
                player.errors++; 
                
                // Feedback visual de erro LIMPO
                const originalPlaceholder = input.placeholder;
                input.placeholder = `‚ùå ERROU! (-${SCORE_PENALTY} pts)`;
                input.classList.add('bg-red-500/50', 'placeholder-red-400', 'font-bold');
                
                setTimeout(() => {
                    input.classList.remove('bg-red-500/50', 'placeholder-red-400', 'font-bold');
                    if (player.guessesLeft > 0) input.placeholder = originalPlaceholder;
                }, 1500);

                renderScoreBoard();
                
                document.getElementById(`guesses-left-${playerId}`).textContent = `(${player.guessesLeft} Chutes)`;
                
                if (player.guessesLeft <= 0) {
                    input.disabled = true;
                    input.placeholder = 'SEM CHUTES RESTANTES!';
                    input.classList.add('disabled-guess');
                    document.getElementById(`guess-btn-${playerId}`).disabled = true;
                }

                const allDone = gameState.players
                    .filter(p => p.id !== gameState.drawerId)
                    .every(p => p.guessesLeft <= 0 || gameState.playersWhoGuessed.has(p.id));
                
                if (allDone) endRound();
            }
        }
        
        function endRound() {
            if (gameState.timer) clearInterval(gameState.timer);
            
            document.getElementById('guessing-screen').classList.add('hidden');
            document.getElementById('drawing-screen').classList.add('hidden');
            document.getElementById('round-end-screen').classList.remove('hidden');

            document.getElementById('final-word').textContent = gameState.wordToDraw;
            
            const drawer = gameState.players.find(p => p.id === gameState.drawerId);
            const correctList = document.getElementById('correct-guesses-list');
            correctList.innerHTML = '';
            
            // --- PONTUA√á√ÉO DO DESENHISTA ---
            document.getElementById('drawer-name-end').textContent = drawer.name;
            const drawerScoreEarnedEl = document.getElementById('drawer-score-earned');
            if (gameState.hasDrawerScored) {
                 drawerScoreEarnedEl.innerHTML = `<span class="text-green-400 font-extrabold">+${SCORE_DRAWER} pts</span>`;
            } else {
                 drawerScoreEarnedEl.innerHTML = `<span class="text-gray-400 font-extrabold">+0 pts</span>`;
            }

            // --- PONTUA√á√ÉO DOS ADIVINHOS E PENALIDADES ---
            const guessers = gameState.players.filter(p => p.id !== gameState.drawerId);

            guessers.forEach(player => {
                const li = document.createElement('li');
                li.className = "flex justify-between items-center p-3 rounded-md";

                if (gameState.playersWhoGuessed.has(player.id)) {
                    const timeBonus = Math.max(0, gameState.timeLeft) * SCORE_BONUS_PER_SEC;
                    const baseScore = SCORE_GUESSER_BASE;
                    const perfectBonus = player.errors === 0 ? SCORE_PERFECT_GUESS : 0;
                    const totalScore = baseScore + timeBonus + perfectBonus;
                    
                    li.className += " bg-green-900/50 border border-green-600";
                    li.innerHTML = `
                        <span class="font-bold text-white">${player.name}</span>
                        <span class="flex items-center space-x-3">
                            <span class="text-xs text-yellow-400 font-bold hidden sm:inline-block">${baseScore} Base</span>
                            <span class="text-xs text-blue-400 font-bold hidden sm:inline-block">+${timeBonus} Tempo</span>
                            ${perfectBonus > 0 ? `<span class="text-pink-400 font-bold text-xs hidden sm:inline-block">+${perfectBonus} PERFEITO</span>` : ''}
                            <span class="text-green-500 font-extrabold text-xl">+${totalScore}</span>
                        </span>
                    `;
                } else {
                    const penalties = player.errors * SCORE_PENALTY;
                    
                    li.className += " bg-red-900/50 border border-red-600";
                    li.innerHTML = `
                        <span class="font-semibold text-red-300">${player.name} (Errou)</span>
                        <span class="text-red-400 font-extrabold text-xl">-${penalties}</span>
                    `;
                }
                correctList.appendChild(li);
            });
            
            if (gameState.playersWhoGuessed.size === 0) {
                 correctList.innerHTML = '<li class="text-red-500 text-center py-4">Ningu√©m acertou esta palavra.</li>';
            }
            
            renderScoreBoard();
        }

        function endGame() {
            // Esconde todas as telas de jogo para garantir
            document.getElementById('drawing-screen').classList.add('hidden');
            document.getElementById('round-end-screen').classList.add('hidden');
            document.getElementById('guessing-screen').classList.add('hidden');
            // Mostra a tela de fim de jogo
            document.getElementById('game-end-screen').classList.remove('hidden');

            const ranking = [...gameState.players].sort((a, b) => b.score - a.score);

            const rankingDiv = document.getElementById('final-ranking');
            rankingDiv.innerHTML = '';
            
            ranking.forEach((player, index) => {
                const rankItem = document.createElement('div');
                let bgColor = index === 0 ? 'bg-yellow-700' : 'bg-gray-800';
                let rankLabel = index === 0 ? 'ü•á 1¬∫ Lugar' : `${index + 1}¬∫ Lugar`;

                rankItem.className = `flex justify-between items-center p-4 rounded-xl font-bold shadow-lg ${bgColor} transform hover:scale-[1.02] transition duration-200`;
                rankItem.innerHTML = `<span class="text-lg text-purple-300">${rankLabel}</span><span class="text-xl text-white">${player.name}</span><span class="text-2xl text-accent-color font-extrabold">${player.score}</span>`;
                rankingDiv.appendChild(rankItem);
            });
        }
        
        function nextRound() {
            startNextRound();
        }

        // --- Fun√ß√µes de Interface (Desenho, Inputs, Placar) ---
        function setupCanvasListeners() {
            const events = {
                'mousedown': startDrawing, 'mousemove': draw, 'mouseup': stopDrawing, 'mouseout': stopDrawing,
                'touchstart': startDrawing, 'touchmove': draw, 'touchend': stopDrawing
            };
            for (const type in events) {
                canvas.addEventListener(type, events[type], { passive: type.startsWith('touchmove') ? false : true });
            }
            document.getElementById('color-picker').addEventListener('input', (e) => { color = e.target.value; });
            window.addEventListener('resize', resizeCanvas);
            setMode('pen');
        }

        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            
            if (container && canvas) {
                const rect = container.getBoundingClientRect();
                const imgData = ctx ? ctx.getImageData(0, 0, canvas.width, canvas.height) : null;
                
                // Aspect ratio fixo para o desenho (4:3)
                const aspectRatio = 4 / 3;

                canvas.width = rect.width;
                canvas.height = rect.width / aspectRatio; 
                
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                if (imgData) { ctx.putImageData(imgData, 0, 0); } else { clearCanvas(); }
            }
            
            // CORRE√á√ÉO FINAL: Redimensionamento do desenho final (final-drawing-canvas)
            const finalCanvas = document.getElementById('final-drawing-canvas');
            if (finalCanvas && finalCanvas.dataset.hasImage === 'true') {
                 const finalCtx = finalCanvas.getContext('2d');
                 const tempImg = new Image();
                 tempImg.onload = function() {
                      const rect = finalCanvas.parentNode.getBoundingClientRect();
                      const aspectRatio = tempImg.width / tempImg.height;
                      finalCanvas.width = rect.width;
                      finalCanvas.height = rect.width / aspectRatio;
                      finalCtx.drawImage(tempImg, 0, 0, finalCanvas.width, finalCanvas.height);
                 };
                 tempImg.src = canvasDrawingData;
            }
        }
        function draw(e) {
             if (!isDrawing || !gameState.isDrawingPhase || mode === 'fill') return;
            let clientX, clientY;
            if (e.touches) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; e.preventDefault(); } else { clientX = e.clientX; clientY = e.clientY; }
            const rect = canvas.getBoundingClientRect();
            let newX = clientX - rect.left;
            let newY = clientY - rect.top;
            ctx.beginPath();
            if (mode === 'pen') { ctx.strokeStyle = color; ctx.lineWidth = size; } 
            else if (mode === 'eraser') { ctx.strokeStyle = '#ffffff'; ctx.lineWidth = size * 2; }
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(newX, newY);
            ctx.stroke();
            [lastX, lastY] = [newX, newY];
        }
        function startDrawing(e) {
            if (!gameState.isDrawingPhase || gameState.timeLeft <= 0) return;
            let clientX, clientY;
            if (e.touches) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; } else { clientX = e.clientX; clientY = e.clientY; }
            const rect = canvas.getBoundingClientRect();
            const startX = Math.floor(clientX - rect.left);
            const startY = Math.floor(clientY - rect.top);
            if (mode === 'fill') { floodFill(startX, startY); } 
            else { isDrawing = true; [lastX, lastY] = [startX, startY]; draw(e); }
        }
        function stopDrawing() { isDrawing = false; }
        function setMode(newMode) {
            mode = newMode;
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active', 'bg-blue-700', 'bg-yellow-500', 'bg-red-600');
                if (btn.id === newMode + '-btn') {
                    btn.classList.add('active');
                    if (newMode === 'pen') btn.classList.add('bg-blue-700');
                    if (newMode === 'eraser') btn.classList.add('bg-yellow-500');
                    if (newMode === 'fill') btn.classList.add('bg-red-600');
                } else {
                    if (btn.id === 'pen-btn') btn.classList.add('bg-blue-600', 'hover:bg-blue-700');
                    if (btn.id === 'eraser-btn') btn.classList.add('bg-yellow-400', 'hover:bg-yellow-500');
                    if (btn.id === 'fill-btn') btn.classList.add('bg-red-500', 'hover:bg-red-600');
                }
            });
        }
        function setSize(newSize) {
            // L√≥gica do Slider
            size = parseInt(newSize, 10);
            document.getElementById('brush-size-slider').value = size;
            document.getElementById('brush-size-value').textContent = size;
        }
        function clearCanvas() {
            if (ctx) {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }
        function renderGuesserInputs() {
            const container = document.getElementById('guesser-inputs');
            container.innerHTML = '';
            const guessers = gameState.players.filter(p => p.id !== gameState.drawerId);
            guessers.forEach(player => {
                const inputDiv = document.createElement('div');
                inputDiv.className = 'flex flex-col gap-1'; 
                
                const isDisabled = player.guessesLeft <= 0 || gameState.playersWhoGuessed.has(player.id);
                
                inputDiv.innerHTML = `
                    <span class="font-bold text-base text-gray-100">${player.name} <span id="guesses-left-${player.id}" class="text-red-400 text-xs font-bold"> (${player.guessesLeft} Chutes)</span>:</span>
                    
                    <div class="flex gap-2">
                        <input type="text" id="guess-${player.id}" data-player-id="${player.id}"
                               class="guesser-input input-text-dark flex-grow p-3 rounded-xl focus:ring-2 focus:ring-green-500 disabled:opacity-70 disabled:bg-gray-700 shadow-inner placeholder-gray-500"
                               placeholder="Seu palpite. (Enter)"
                               onkeyup="if(event.key === 'Enter') handleGuess(event, '${player.id}', false)"
                               ${isDisabled ? 'disabled' : ''}>
                        
                        <button onclick="handleGuess(event, '${player.id}', true)" 
                                id="guess-btn-${player.id}"
                                class="px-3 py-2 bg-accent-color text-white rounded-xl font-bold hover:bg-green-700 transition duration-200 shadow-md text-sm whitespace-nowrap"
                                ${isDisabled ? 'disabled' : ''}>
                            Palpite
                        </button>
                    </div>
                `;
                container.appendChild(inputDiv);
                
                // Define o placeholder correto se estiver desabilitado no in√≠cio
                if (isDisabled) {
                    const inputEl = document.getElementById(`guess-${player.id}`);
                    if (gameState.playersWhoGuessed.has(player.id)) {
                        inputEl.placeholder = 'ACERTOU!';
                    } else {
                        inputEl.placeholder = 'SEM CHUTES RESTANTES!';
                    }
                }
            });
        }
        function renderScoreBoard() {
            const board = document.getElementById('score-board');
            board.innerHTML = '';
            const sortedPlayers = [...gameState.players].sort((a, b) => b.score - a.score);
            sortedPlayers.forEach(player => {
                const scoreItem = document.createElement('div');
                const isDrawer = player.id === gameState.drawerId;
                scoreItem.className = `flex justify-between items-center p-3 rounded-lg ${isDrawer ? 'bg-blue-900 font-bold border border-blue-600' : 'bg-gray-800'} shadow-sm`;
                scoreItem.innerHTML = `<span class="text-gray-100 truncate">${player.name} ${isDrawer ? 'üé®' : ''}</span><span class="text-xl text-accent-color font-extrabold">${player.score}</span>`;
                board.appendChild(scoreItem);
            });
        }
        
        // --- Fun√ß√µes de suporte para o setup ---
        function removePlayer(id) { gameState.players = gameState.players.filter(p => p.id !== id); updateSetupState(); renderPlayerList(); }
        function renderPlayerList() {
            const playerListDiv = document.getElementById('player-list');
            playerListDiv.innerHTML = '';
            gameState.players.forEach(player => {
                const chip = document.createElement('div');
                chip.className = 'flex items-center bg-blue-800 text-blue-200 text-sm font-semibold px-4 py-2 rounded-full shadow-sm transition duration-200';
                chip.innerHTML = `<span>${player.name}</span><button onclick="removePlayer('${player.id}')" class="ml-2 text-blue-200 hover:text-red-400 transition duration-150 font-bold text-lg leading-none">&times;</button>`;
                playerListDiv.appendChild(chip);
            });
        }
        function updateSetupState() {
            const numPlayers = gameState.players.length;
            const hasThemes = gameState.selectedThemes.length > 0;
            const canStart = numPlayers >= 2 && numPlayers <= 10 && hasThemes;
            document.getElementById('start-game-btn').disabled = !canStart;
            document.getElementById('setup-error').classList.toggle('hidden', canStart);
        }
        function renderThemeSelection() {
            const themeSelectionDiv = document.getElementById('theme-selection');
            themeSelectionDiv.innerHTML = '';
            Object.keys(WORD_CATEGORIES).forEach(theme => {
                const isActive = gameState.selectedThemes.includes(theme);
                const button = document.createElement('button');
                button.value = theme;
                button.textContent = theme;
                button.type = 'button'; 
                button.onclick = () => {
                    const index = gameState.selectedThemes.indexOf(theme);
                    if (index > -1) { gameState.selectedThemes.splice(index, 1); } 
                    else { gameState.selectedThemes.push(theme); }
                    renderThemeSelection(); 
                    updateSetupState();
                };
                button.className = `toggle-btn px-4 py-2 rounded-full text-sm font-semibold shadow-md whitespace-nowrap transition duration-200 ${isActive ? 'bg-blue-600 text-white hover:bg-blue-700 active' : 'bg-gray-700 text-gray-100 hover:bg-gray-600'}`;
                themeSelectionDiv.appendChild(button);
            });
        }
        function addPlayer() {
            const name = document.getElementById('new-player-name').value.trim();
            if (name && gameState.players.length < 10) {
                const newPlayer = { name: name, score: 0, id: Date.now().toString() + Math.random().toString(16).substring(2, 5), guessesLeft: 3, errors: 0 };
                gameState.players.push(newPlayer);
                document.getElementById('new-player-name').value = '';
                renderPlayerList();
                updateSetupState();
            }
        }

        window.onload = () => {
            const initialSetup = () => {
                document.body.classList.add('dark');
                document.documentElement.classList.add('dark');

                renderPlayerList();
                renderThemeSelection();
                updateSetupState();

                setTimeOption('30', document.querySelector('#time-selector button[data-time="30"]'));
                setRoundMode('alternated', document.querySelector('#round-mode-selector button[data-mode="alternated"]'));
            };
            initialSetup();
        };

    </script>
</body>
</html>
